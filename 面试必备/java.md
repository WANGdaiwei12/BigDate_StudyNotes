[TOC]



#### java

##### 线程的同步方法有几种

```tex
1.同步方法： 用synchronized关键字修饰方法。
2.特殊域变量(volatile)
3.同步代码块  即有synchronized关键字修饰的语句块。
4.重入锁（ReentrantLock ） 在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。
ReenreantLock类的常用方法有：
    ReentrantLock() : 创建一个ReentrantLock实例
        lock() : 获得锁
        unlock() : 释放锁
 5.使用线程局部管理ThreadLocal   存在问题
```



##### 接口和抽象类的区别

```tex
接口和抽象类的异同？
接口更多的是在系统框架设计方面发挥作用，主要定义模块之间的通信，而抽象类在代码实现方面发挥作用，可以实现代码的重用。
(1)相同点：
①都不能被实例化，都可以包含抽象方法，都可以继承
(2)不同点：
①抽象类中可以定义属性、方法、构造器，代码块，但接口在1.8之前只能定义常量和抽象方法，1.8之后可以定义静态方法和默认方法，接口可以看作是一个抽象类
②一个类只能继承一个抽象类，但可以被多个接口实现，接口之间也可以继承
③抽象类中的抽象方法和属性的访问类型可以是public、protected和默认类型，但接口中的抽象方法和属性只能是public类型的，且默认是public abstract 类型的
```

##### ArrayList和LinkedList  

```tex
ArrayList的底层是数组，一个索引对应一个元素，所以查询速度快；但是在增删时，需要调整整组数据的移动，所以增删较慢。
而LinkedList的底层是双向链表，每次查询时都要从两头开始查询（离头近就从头查，离尾近就从尾查），所以查询较慢；但是增删时，只需要将链表头结点和尾结点指向新插入的结点即可，所以增删速度较快。
但如果是新增的数据量较大的情况下，ArrayList的新增效率比LinkedList的效率更高。因为ArrayListr底层数组的扩容是1.5倍，数据量越大，扩容的速度就越快，而链表仍需一个个断开链接和重续新链接。
jdk8之后变成了只有放入第1个元素时，才会开辟10个空间。
```

##### HashMap的底层实现原理           

```tex
put实现原理
    JDK8以前，Hash表的底层是【数组】+【链表】
    JDK８及之后，变成了【数组】+【链表】+【红黑树】
    在实例化后首次调用put方法时,底层创建了一个长度为16的node[]table。
    首先，调用键所在类的hashCode()计算key1的哈希值，此哈希值经过某种算法计算以后，得到node数组中的存放位置。如果没有数据，添加数据，
    如果此位置上的数据不为空，会调用k所在的类的hashcode方法和已经存在的多个数据进行哈希码值比较，都不同的话，添加成功，如果出现相同的，会使用k所在类的equals方法进行比较，如果equals（）返回false；此时key1-value1添加成功，如果equals（）返回true；此时value1会替换相同key的value值
 get实现原理
     1.先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标。
    根据下标快速定位到数据位置。如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。

扩容机制，什么时候切换成红黑树
    Hash表中数组的分手手动初始化，和自动初始化，自动初初始会在第一次插入元素时开辟空间，默认长度为16，扩容因子为0.75，每次扩容量为自身的2倍长度。
    当数组的某一个索引位子上的元素以链表形式存在的数据个数>8 且 当前长度>64时，此时此索引位置上的所有数据改为使用红黑树存储
    优点：红黑树可以排序，方便查找元素
```

##### 创建线程的方式以及Rubbale和Callable的区别

```tex
1.继承java.lang. Thread，重写run方法。 
2.实现java.lang. Runnable接口，实现run方法
3.实现callable接口，重写call方法
4.使用线程池

1.call()方法可以有返回值
2.Call()方法可以抛出异常，被外面的操作捕获 
3.Callable支持泛型
```

##### 线程有哪几种状态

```tex
1.新建状态（new）--创建线程
2.就绪状态（runnable）--start方法
3.阻塞状态（blocked）--无法获取锁对象（线程没抢到）
4.等待状态（waiting）--wait方法
5.计时状态（timed waiting）--sleep方法
6.死亡状态（terminated）--代码运行完毕
```

##### sleep和wait的区别、notify()和notifyAll()有什么区别？

```tex
sleep方法不会释放资源，期间其他线程不能进来，自动苏醒，而wait可以释放资源，其他线程可以进来。另外wait不会自动苏醒，需要调用一个notify()方法或者notifyAll()方法来唤醒。

notifyAll() 会唤醒所有的线程，notify() 只会随机唤醒一个线程
```

##### 有哪几种常见的线程池

1.单例线程池（newSingleThreadExecutor）
2.固定大小线程池（newFixedThreadPool）
3.可缓存线程池（newCachedThreadPool）
4.大小无限线程池（newScheduledThreadPool）

##### Synchronized的作用是什么 ，synchronized与Lock的区别

```tex
synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行，即保证线程的串行化。
synchronized 可以保证可见性、原子性、有序性三大特性。
区别：
  1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；

  2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；

  3. synchronized机制在执行完相应的同步代码以后，自动地释放同步监视器

​    Lock需要手动的启动同步(lock()),同时结束同步也需要手动的实现（unlock()）

  4.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
```

##### synchronized可重入的原理           

重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁，且不再被阻塞。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。

##### Syncrhronized怎么保证可见性          

JMM中使用happens-before语义（即遵循happens-before关系，由JMM定义的规则）：

1）线程解锁前，必须把共享变量的最新值刷新到主内存中。

2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值。

（注意：加锁与解锁需要是同一把锁）
 通过以上两点，可以看到synchronized能够实现可见性

##### 死锁、 悲观锁、 乐观锁、 行级锁 、表级锁

```tex
死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己所需要的同步资源，就形成了线程的死锁
	解决：避免锁的嵌套，2.设置超时时间，使用JUC包中lock接口提供的trylock方法3.降低锁的使用粒度，用不同的锁 4.尽量使用同步方法 而不是同步代码块


悲观锁：执行操作前假设当前的操作肯定（或有很大几率）会被打断（悲观）。基于这个假设，我们在做操作前就会把相关资源锁定，不允许自己执行期间有其他操作干扰。

乐观锁：执行操作前假设当前操作不会被打断（乐观）。基于这个假设，我们在做操作前不会锁定资源，万一发生了其他操作的干扰，那么本次操作将被放弃。Redis使用的就是乐观锁。

行级锁：是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。

表级锁：是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。
```





##### java虚拟机主要分为以下几个区:

```tex
方法区，虚拟机栈，本地方法栈，堆，程序计数器
1.方法区
主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用
2.虚拟机栈（栈内存）
方法执行的地方，执行的时候创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息，局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用
3.本地方法栈
本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务
4.堆：
通过new关键字, 创建对象都会使用堆内存
特点：
它是线程共享的, 堆中对象都需要考虑线程安全的问题
有垃圾回收机制(不在被引用的对象会被回收）
5.程序计数器
程序计数器（Program Counter Register）是一块较小的内存空间，它记录了当前线程所执行的字节码的行号
```

##### java类加载过程

```tex
加载、验证、解析、初始化  4个阶段
1)加载
加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：
a.通过一个类的全限定名获取该类的二进制流。
b.将该二进制流中的静态存储结构转化为方法去运行时数据结构。 
c.在内存中生成该类的Class对象，作为该类的数据访问入口。
2)验证
验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证: 
	a.文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. 
	b.元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。
	c.字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。
	d.符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。
	e.准备
	准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
3)解析
该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。
4)初始化
初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。
```

##### 什么是类加载器，类加载器有哪些?

```tex
实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。
主要有一下四种类加载器: 
1)启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
2)扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3)系统类加载器（system class loader）也叫应用类加载器：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
4)用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。
```

##### IOC、AOP

ioc控制反转，他是一个思想，用于程序间的耦合问题。原本我们在创建对象时，控制权是在我们自己手中，需要我们自己来new对象，在这里我们就把这个控制权交给Spring来管理，我们可以通过配置文件来配置即可。简单来说就是一个工厂，只不过比普通的要强大很多。	

IOC原理:工厂模式+反射机制

aop是面向切面编程，在面向切面编程中，可以将一些对象中相似的方面抽成一个切面，进行统一管理，进行一些公共的操作。比如日志、事务处理等

##### Spring 框架中都用到了哪些设计模式

```tex
工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；

单例模式：Bean默认为单例模式。

代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；

模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。

观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。
```

##### Spring MVC执行流程

1.用户发送请求到前端控制器
2.前端控制器获得请求后，调用处理器映射器，获得请求处理器
3.处理器映射器根据请求URL找到具体的处理器，生成处理器对象以及处理器拦截器一并返回给前端控制器
4.前端处理器调用HandlAdapter，经过适配调用具体的处理器Handler
5.处理器Handler执行完成后返回ModelAndView，通过调用视图解析器ViewResolver，解析视图返回具体的View
6.前端处理器对返回的视图View进行渲染，填充到对应的模型中最后响应给用户

#### mysql

##### 3范式

```tex
1.数据库表中的所有字段值都是不可分割的原子值
2.基于第一范式，实体的属性完全依赖于主关键字
3.基于第二范式，属性不依赖其他非主属性
```



##### 存储过程和函数的区别，======count(1),count(*),count(字段)

```tex
存储过程是一个预编译的SQL语句，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快；
区别：
1：存储过程可以返回参数，如记录集，函数只能返回变量或表对象
2：函数可以嵌⼊sql或存储过程中使⽤，但是存储过程需要call来调用
3：存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。

执行效果上 ：count(*)和count(1)：对表中行数进行统计计算，包含null值
	count(某字段)：对表中该字段的行数进行统计，不包含null值。如果出现空字符串，同样会进行统计。

效率上：列名为主键，count(指定字段)会比count(1)快
	 列名不为主键，count(1)会比count(指定字段)快
	 表中只有一个字段的时候，count(*) 最优
```



##### sql优化

```tex
1.避免不走索引的场景，比如 in，not in，or，模糊查询都不会走索引
2.SELECT语句其他优化，行列裁剪，只拿自己需要的列，多表关联的的时候小表在前，大表在后，避免全表扫描大表，也可以根据条件先进行过滤，然后在进行关联查询
3. 查询条件的优化，比如对于复杂的查询，，可以使用中间临时表，优化group by语句，它默认是会对分组进行排序的，如果不需要可以order by null禁止排序
4.建表优化的，建立索引，优先考虑where、order by用到的字段 ，尽量考虑使用数字类型，比如性别，可以用1,2来代替，varchar代替char， 因为varchr可变字段，存储空间小，插入的长度小于定义长度时，插入多长就存多长 ，节省内存，char定长字段，无论存储的数据有多少都会固定长度，查找效率会比较高
```

##### 数据库优化

```tex
1）提升硬盘配置，换SSD固态硬盘，硬件直接决定了磁盘读写的快慢。
2）设计索引的时候，尽量保证主键足够小。
3）对数据库结构优化，索引可以适当冗余，可以减少多表联查。
4）尽量保证数据的有序性，提升批量插入的性能。
5）分库分表。
```

##### sql的生命周期

```tex
应用服务器与数据库建立连接
数据库进程拿到请求的sql
然后进行解析并执行
数据读取到内存并进行处理
然后再与应用服务器连接，发送结果到客户端
关闭连接，释放资源
```

##### mysql使用的索引的分类

1. hash类型的索引：查询单条快，范围查询慢
2. btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）

Mysql常用的索引有两种B-tree(实际是B+Tree)和Hash
B-tree是一个树，从根节点开始，对节点内的索引值序列采用二分法查找，如果命中就结束查找。没有命中会进入子节点重复查找过程，直到所对应的的节点指针为空，或已经是叶子节点了才结束。
B+Tree与B 树的区别主要在于

##### 聚簇索引(主键索引)、唯一索引 、复合索引、 非聚簇索引、回表、索引覆盖、怎么解决回表

```tex
唯一索引：和主键索引类似，不同的就是：索引字段的值必须唯一，但允许有空值 
复合索引：在多个列上建立索引，这种索引叫做组复合索引（组合索引）
全文索引（FULLTEXT）：MyISAM存储引擎支持全文索引，从MySQL 5.6开始MyISAM和InnoDB存储引擎均支持
	
聚簇索引:聚簇索引是一种数据存储方式,与储存数据在一块，找到索引就找到了数据。
	如果表定义了主键，则主键索引就是聚簇索引
	如果表没有定义主键，则第一个非空unique（唯一）列作为聚簇索引
	否则InnoDB会从建一个隐藏的row-id作为聚簇索引
非聚簇索引：也叫辅助索引、二级索引，往往需要回表查询。
回表：根据非聚簇索引查到聚簇索引的信息，再根据聚簇索引查到所有的数据，进行了2次B+树，这种现象就叫做回表。
索引覆盖：就是非聚簇索引查询自己，不走聚簇索引，比如查询id和name,name是非聚簇索引，这样就不用走聚簇索引，直接就可以查出来，这就叫索引覆盖。
解决回表：就是查询你所需要的数据，不用select * ，使用索引覆盖。
```

##### hash索引的优点及缺点

```tex
Hash索引优点： 
	Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 
	Hash索引缺点： 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；
	Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。
```

##### MyISAM与InnoDB 的区别

  1. innoDb支持事务，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，适合读和写操作，myISAM更适合于快速查询

  2. innoDB支持外键，myISAM不支持，对一个包含外键的InnoDB表转为MYISAM会失败

  3. InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高

     myISAM是非聚集索引，使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

  4. InnoDB不保存表的具体行数，执行select count(\*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快

  5. Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了

  6. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁，InnoDB的行锁是实现在索引上的，如果访问没有命中索引，也无法使用行锁，将要退化为表锁

##### b+tree 和b-Tree的区别

```tex
1) B-树的关键字、索引和记录是放在一起的， B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。
2) 在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。
```

##### 索引的设计原则

1.索引数不能超过5个
2.最左原则，如果是模糊查询就不会走索引
3.创建索引的值尽量要小
4.尽可能创建覆盖索引，减少回表操作

##### 百万级别或以上的数据如何删除

可以先删除索引（大约两三分钟），然后删除没有的一些数据，删除完成后重新创建索引。

##### Mysql怎么处理事务的

通过InnoDB来处理
	redo log来重做日志保证事务的持久性：
		当commit时，必须先将事务的所有日志写到重做的日志文件中，来保证数据的持久化，知道commit结束日志才算完成。
	undo log回滚日志保证事务的原子性：
		事务完成前，操作并没有真正执行，而是记录在日志中，undo log会记录自前事务对应的数据，回滚时，会根据日志进行法向操作，对中间记录的每一个操作进行逻辑删除，从而保证原子性。
	undo log+redo log保证事务的一致性：
		操作过程中由redo log来保证数据的持久化，当发生错误时，就由undo log来进行回滚。
	锁用来保证事务的隔离性：
		事务的隔离性就是锁来实现的，InnoDB主要有两种锁，行级锁和意向锁。

##### 	Mysql的事务隔离机制

分为四种:
		1.读未提交:可能会存在 脏读+不可重复读+幻读的问题。
		2.读已提交：可能存在 不可重复读+幻读的问题。
		3.可重复读：可能存在幻读的问题。
		4.串行化：就是没有上面那些问题，但效率低
		
脏读：
	就是一个事务在处理过程中读取了另一个未提交的事务中的数据，导致两次查询的结果不一致。
不可重复读：
	在事务开启后关闭前，多次读取同一条记录，结果却不能保持一致。
幻读：
	某记录是否存在，不存在，准备插入此纪录时，但执行了insert发现记录存在，无法插入。或者不存在执行delete时，却删除不了。

事务的默认隔离级别：
	可重复读。因为之前的版本中的binlog支支持statement这种格式，所以他的默认级别是可重复读。		

#####  事务的四大特性是什么

ACID（只有InnoDB才支持事务）。

**原子性**（undo log回滚保证事务的原子性）：指同一对的事务操作，要么全成功，要么全失败，操作失败不能对数据库有影响。

**一致性**（undo log+redo log保证事务一致性）：事务操作之后，数据库内的数据总量保持一致。（能量守恒）

**隔离性**（锁保证事务隔离性）：相同的表，不同事务之间不能互相干扰。

**持久性**（redo log重做日志用来保证事务持久性）：事务一旦被提交，就需要在数据永久化存储，即便故障也不会丢失提交事务的操作。
