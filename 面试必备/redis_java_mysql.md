[TOC]



#### list

##### 接口和抽象类的区别

```tex
接口和抽象类的异同？
(1)相同点：
①都不能被实例化，都可以包含抽象方法，都可以继承
(2)不同点：
①抽象类中可以定义属性、方法、构造器，代码块，但接口在1.8之前只能定义常量和抽象方法，1.8之后可以定义静态方法和默认方法，接口可以看作是一个抽象类
②一个类只能继承一个抽象类，但可以被多个接口实现，接口之间也可以继承
③抽象类中的抽象方法和属性的访问类型可以是public、protected和默认类型，但接口中的抽象方法和属性只能是public类型的，且默认是public abstract 类型的
④接口更多的是在系统框架设计方面发挥作用，主要定义模块之间的通信，而抽象类在代码实现方面发挥作用，可以实现代码的重用。
```

##### ArrayList和LinkedList       

首先，List集合是有序集合，即存取有序，List集合的特点是存取顺序一致，存储元素可重复，都有索引。

ArrayList的底层是数组，一个索引对应一个元素，所以查询速度快；但是在增删时，需要调整整组数据的移动，所以增删较慢。

而LinkedList的底层是双向链表，每次查询时都要从两头开始查询（离头近就从头查，离尾近就从尾查），所以查询较慢；但是增删时，只需要将链表头结点和尾结点指向新插入的结点即可，所以增删速度较快。

但如果是新增的数据量较大的情况下，ArrayList的新增效率反面比LinkedList的效率更高。因为ArrayListr底层数组的扩容是1.5倍，数据量越大，扩容的速度就越快，而链表仍需一个个断开链接和重续新链接。

最后，jdk8版还对ArrayList做了懒加载优化，在之前是构造ArrayList时就默认开辟10个空间，jdk8之后变成了只有放入第1个元素时，才会开辟10个空间。

##### 你了解TreeSet的底层原理吗？分别讲一下Set集合和Tree这种数据结构
 Set集合的特点是必须排序，没有索引，不可重复。Set集合分为HashSet和TreeSet，HashSet底层使用的是哈希表，它的排序规则是按照底Hash函数决定的，无法人为设置；而TreeSet的底层则是使用红黑树，可以使用自然排序（自定义类中实现Comparable接口，重写CompareTo方法）或比较器排序（在创建TreeSet对象创建一个Comparator的匿名内部类，并重写Compare方法），扩容时通过结点链接。

红黑树又叫平衡二叉B树，它的结构模型十分有趣，红黑树不是绝对平衡，而是有着自己的平衡方式，为了保证数据高效查询，红黑树所有结点排成一条线后一定是左小右大的，并且在插入新的结点时，会通过左旋和右旋的方式来平衡二叉数。
          
红黑树的5个平衡规则：1、节点非红即黑2、根节点必须为黑3、叶节点必须为黑4、不能双红5、任何一个节点到其任一的叶节点的简单路径上，黑色节点的数量相同。
红黑树插入结点时的变化：        
1、插入红节点在根节点时，变黑
2、插入红节点在非根节点，父节点为黑时，不变
3、插入红节点在非根节点，父节点为红，叔节点为红时：父节点和叔节点都变黑，祖父节点变红（如果祖父节点是根结点，仍黑）
4、插入红节点在非根节点，父节点为红，叔节点为黑时：爷节点变黑，祖父节点变红（根仍黑），并以祖父节点为支点旋转。

##### HashMap的底层实现原理           
JDK8以前，Hash表的底层是【数组】+【链表】
JDK８及之后，变成了【数组】+【链表】+【红黑树】
存入新键值对时，如果出现哈希冲突，会先判断键是否相同，如果键相同，会比较值，值相同则不放入，值不同则修改原值；如果键不相同，则会以链表形式挂下来，并且1.7版本中是头插法，1.8版本是尾插法。

##### 什么是哈希冲突
哈希冲突就是两个元素在通过哈希函数后，得到的角标是相同的，在同一个哈希槽中。哈希冲突的四种解决思路分别是：重哈希法，开放地址法，建立公共溢出，链地址法

##### HashMap的扩容机制是怎么样的？它什么时候会转化为红黑树？
Hash表中数组的分手手动初始化，和自动初始化，自动初初始会在第一次插入元素时开辟空间，默认长度为16，扩容因子为0.75，每次扩容量为自身的2倍长度。
HashMap1.7版本的的扩容时机是先判断是否达到阈值，达到先扩容，再添加元素，并且采用的是头插法，也就是旧元素挂在新元素下。
而HashMap1.8的扩容时机是先添加元素是否达到阈值，达到直接扩容，且使用的是尾插法，即新元素挂在旧元素下面。
当存入新的键值对时，会先判断数组长度是否大于64，再判断链表元素是否大于等于8时，如果两者都成立，链表会自动转换成红黑树，如果数组小于64，会从第9个开始先扩容，直到数组大于等于64时，链表长度再增加，就会转为红黑树。



##### 持久化方式
1）RDB： RDB就是将内存中的数据以二进制快照的方式记录到硬盘中，当Redis出现故障重启后，会从硬盘中读取快照文件，来进行一个数据回复。
执行bgsave命令
	执行bgsave命令时,Redis进程会判断当前是否存在执行RDB或者AOF
	然后会执行fork操作创建一个子进程，此时别的请求是进不来的，以免导致数据的不一致
	然后子进程开始对内存中的数据进行一个读操作，写到新的RDB文件中，会覆盖旧的RDB文件
	当子进程对数据读完后，主进程就会对副本数据和子进程读取的数据进行一个写的操作

2）AOF：Redis处理的每一个写命令都会记录在AOF文件中，也可以看作是一个命令日志文件。
因为记录的时命令，所以AOF对RDB文件大。
如果同一个key多次操作的话，也一直会记录这些操作但只有最后的写操作才有意义，可以通过执行bgrewriteaof命令让AOF文件执行重写功能，用最少的命令达到一个相同的效果。

在实际应用中我们会对两个结合来进行使用。


##### 热点数据持久化
采用淘汰策略：
	使用次数最少的
    使用最近一次时间距现在最久的
    过期时间最近的
	

##### 数据持久化失效
采用集群主从的方式，如果主服务器失效，就用从服务器的。

##### 怎么保持数据库与Redis数据同步
当数据库数据发生改变时，再查询返回更新后的数据，然后再更新到Redis中，如果服务多的情况下，使用MQ来获取Mysql中日志的修改顺序，然后一次发送到Redis，因为Mysql的记录时先后更改后的执行顺序，MQ可以根据这个顺序保证先后的更新顺序，让Redis的顺序不会出现问题。

##### Redis存在的问题
缓存与数据库的一致性
缓存雪崩问题
缓存击穿问题
缓存的并发竞争问题

##### 什么是缓存雪崩，缓存击穿，缓存穿透
缓存雪崩：
	就是指某一时段，缓存中的大量数据过期失效，从而导致大量的请求过来，压力都集中到了数据库
		解决办法：
			1.设置一个缓存过期时间，不要一样的要错开，设置热门数据永不过期
			2.进行多级缓存，每一个缓存都是一个集群，相同的数据在多个服务器之间进行缓存
			3.优化数据库
			
缓存穿透：
	就是反复查询一个不存在的数据，导致数据库压力过大，一般是恶意攻击
		解决办法：
			将这个查询不到的数据设为null，并放入缓存中，在设置一个短的有效时间。
			用户身份验证
			布隆过滤器，对不存在的key直接过滤掉
			
缓存击穿：
	值一个比较热点的数据在缓存中失效了，导致大量请求瞬间到数据库中。
			解决办法:
				就是设置一个比较长的有效时间。
				

##### Redis删除策略
定时删除:
	创建一个定时器，当key设置的过期时间到达时，定时器任务就会立即对键进行删除操作。
	
惰性删除：
	在定时删除中可能存在没有被删除的key，这时就会先判断这个key是否过期，如果过期就删除，如果没过期就进行后续的操作。
	
定期删除：
	Redis默认美一秒钟进行10此过期扫描，在过期字典中随机出20个key，删除这20个key中过期的key，如果过期的key的比率超过1/4，就重复步骤1，同时为了保证线程不被卡死的现象，增加了对扫描时间的上限，默认不超过25ms，如果同一时间大量的key过期，为了避免Redis持续对过期字典的扫描，在设置过期时间时，可以给过期时间设置一个时间范围，
	避免同一时间过期。

##### redis为什么速度快
1.因为大部分请求基于内存操作的
2.采用单线程，避免了不必要的上下文切换和竞争条件
3.非阻塞IO多路复用

##### Redis为什么是单线程的
Redis底层主要是三大部分：IO多路复用+队列+文件事件分派器，文件时间分派器就是用来分派文件执行任务的，并且单但线程的，所以说Redis是单线程的。还有就是Redis是C编写的，基于内存来运行的，所以他的IO速度快，相对来说主要占用的是CPU的资源，如果采用多线程的话反而会导致占用CPU资源过大，降低效率，对于不是处理海量数据的话，使用Redis效率还是比较高的。

#### Mysql

##### count(*),count(1),count(字段)区别

```tex
执行效果上 ：count(*)和count(1)：对表中行数进行统计计算，包含null值
	count(某字段)：对表中该字段的行数进行统计，不包含null值。如果出现空字符串，同样会进行统计。

效率上：列名为主键，count(指定字段)会比count(1)快
	 列名不为主键，count(1)会比count(指定字段)快
	 表中只有一个字段的时候，count(*) 最优
```

##### hash索引的优点及缺点

```tex
Hash索引优点： 
	Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 
	Hash索引缺点： 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；
	Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。
```

##### b+tree 和b-Tree的区别

```tex
1) B-树的关键字、索引和记录是放在一起的， B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。
2) 在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。
```

##### MyISAM与InnoDB 的区别

​	innoDb支持事务，支持外键，支持行级锁（命中索引），支持全文索引（5.7），支持聚簇索引，使用B+Tree作为索引结构，数据文件和索引是绑在一起的且必须要有主键 ，适合修改的场景， myISAM支持全文索引，支持非聚簇索引，使用B+Tree作为索引结构，索引保存的是数据文件的指针，支持表级锁， 更适合于快速查询

##### InnoDB为什么推荐使用自增ID作为主键？

  答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。

##### 索引的设计原则
1.索引数不能超过5个
2.最左原则，如果是模糊查询就不会走索引
3.创建索引的值尽量要小
4.尽可能创建覆盖索引，减少回表操作

##### 百万级别或以上的数据如何删除
可以先删除索引（大约两三分钟），然后删除没有的一些数据，删除完成后重新创建索引。

##### Mysql怎么处理事务的
通过InnoDB来处理
	redo log来重做日志保证事务的持久性：
		当commit时，必须先将事务的所有日志写到重做的日志文件中，来保证数据的持久化，知道commit结束日志才算完成。
	undo log回滚日志保证事务的原子性：
		事务完成前，操作并没有真正执行，而是记录在日志中，undo log会记录自前事务对应的数据，回滚时，会根据日志进行法向操作，对中间记录的每一个操作进行逻辑删除，从而保证原子性。
	undo log+redo log保证事务的一致性：
		操作过程中由redo log来保证数据的持久化，当发生错误时，就由undo log来进行回滚。
	锁用来保证事务的隔离性：
		事务的隔离性就是锁来实现的，InnoDB主要有两种锁，行级锁和意向锁。

##### 	Mysql的事务隔离机制
分为四种:
		1.读未提交:可能会存在 脏读+不可重复读+幻读的问题。
		2.读已提交：可能存在 不可重复读+幻读的问题。
		3.可重复读：可能存在幻读的问题。
		4.串行化：就是没有上面那些问题，但效率低
		
脏读：
	就是一个事务在处理过程中读取了另一个未提交的事务中的数据，导致两次查询的结果不一致。
不可重复读：
	在事务开启后关闭前，多次读取同一条记录，结果却不能保持一致。
幻读：
	某记录是否存在，不存在，准备插入此纪录时，但执行了insert发现记录存在，无法插入。或者不存在执行delete时，却删除不了。

事务的默认隔离级别：
	可重复读。因为之前的版本中的binlog支支持statement这种格式，所以他的默认级别是可重复读。		
#####  事务的四大特性是什么
ACID（只有InnoDB才支持事务）。

**原子性**（undo log回滚保证事务的原子性）：指同一对的事务操作，要么全成功，要么全失败，操作失败不能对数据库有影响。

**一致性**（undo log+redo log保证事务一致性）：事务操作之后，数据库内的数据总量保持一致。（能量守恒）

**隔离性**（锁保证事务隔离性）：相同的表，不同事务之间不能互相干扰。

**持久性**（redo log重做日志用来保证事务持久性）：事务一旦被提交，就需要在数据永久化存储，即便故障也不会丢失提交事务的操作。

##### sql优化

​	1.避免不走索引的场景，

```tex
1.字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描	如果需求是要在前面使用模糊查询
	 解决：1.使用MySQL内置函数INSTR(str,substr) 来匹配
 		  2.使用FullText全文索引，用match against 检索
		  3.数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级
 	2. 尽量避免使用in 和not in，会导致引擎走全表扫描 ，可以使用exists代替
 	3. 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描，可以用union代替or
​	4.尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描，可以给字段添加默认值0
​	5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。
​	6.当数据量大时，避免使用where 1=1的条件
​	7.查询条件不能用 <> 或者 !=
​    8.where条件仅包含复合索引非前置列
​	9.隐式类型转换造成不使用索引，
​	例子：索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。
​	10。order by 条件要与where中条件一致，否则order by不会利用索引进行排序
```

2.SELECT语句其他优化

```tex
1.**避免出现select \***
2.特定针对主从复制这类业务场景，由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致
3.多表关联查询时，小表在前，大表在后，在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。
4. 使用表的别名**，可以减少解析的时间并减少哪些友列名歧义引起的语法错误。
5. 用where字句替换HAVING字句，避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录
    ​where和having的区别：where后面不能使用组函数
6. 调整Where字句中的连接顺序，应将过滤数据多的条件往前放，最快速度缩小结果集。
```

3.增删改 DML 语句优化

```tex
1. 大批量插入数据** 尽量使用Insert into T values(1,2),(1,3),(1,4);
​	原因：	减少SQL语句解析的操作，MySQL没有类似Oracle的share pool，只需要解析一次就能进行数据的插入操作；
​	在特定场景可以减少对DB连接次数
​	SQL语句较短，可以减少网络传输的IO。
​	2.**适当使用commit**
​	事务占用的undo数据块；
​	事务在redo log中记录的数据块；
​	释放事务施加的，减少锁争用影响性能。特别是在需要使用delete删除大量数据的时候，必须分解删除量并定期commit。
3. 避免重复查询更新的数据
   可以通过变量来实现：
   Update t1 set time=now() where col1=1; 
   Select time from t1 where id =1; 
   使用变量后
   Update t1 set time=now () where col1=1 and @now: = now (); 
   Select @now; 
4. **.查询优先还是更新（insert、update、delete）优先**
   MySQL 的默认的调度策略可用总结如下：
   1）写入操作优先于读取操作。
   2）对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。
   3）对某张数据表的多个读取操作可以同时地进行。MySQL 提供了几个语句调节符，允许你修改它的调度策略：
   ​LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE；
   ​HIGH_PRIORITY关键字应用于SELECT和INSERT语句；
   ​DELAYED关键字应用于INSERT和REPLACE语句。
```



4. 查询条件的优化

```tex
1. **对于复杂的查询，可以使用中间临时表 暂存数据**
2.  **优化group by语句**：默认情况下，MySQL 会对GROUP BY分组的所有值进行排序 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序
3. **优化join语句**,使用join 有时候替代not in （子查询） 因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。
4. **优化union查询**，除非确实要消除重复的行，否则建议使用union all
5. **.拆分复杂SQL为多个小SQL，避免大事务**
   - 简单的SQL容易使用到MySQL的QUERY CACHE；
   - 减少锁表时间特别是使用MyISAM存储引擎的表；
   - 可以使用多核CPU。
6. 使用truncate代替delete
   当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。
   使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。
7.  使用合理的分页方式以提高分页效率**：当表数据量较大，翻页越翻到后面执行效率越低，时间越长，可以使用子查询优化，在子查询将分页的数据主键查出来，与主表进行关联，这样每次翻页消耗的资源和时间都基本相同
```

5. 建表优化

```tex
1. 在表中建立索引，优先考虑where、order by使用到的字段。
2. 尽量使用数字型字段**（如性别，男：1 女：2）
3. 查询数据量大的表 会造成查询缓慢**：时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示
4. 用varchar/nvarchar 代替 char/nchar：，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。
```

##### 如何优化数据库？

1）提升硬盘配置，换SSD固态硬盘，硬件直接决定了磁盘读写的快慢。

2）设计索引的时候，尽量保证主键足够小。

3）对数据库结构优化，索引可以适当冗余，可以减少多表联查。

4）尽量保证数据的有序性，提升批量插入的性能。

5）分库分表。

5）模糊查询和海量数据查询使用ES：倒排索引，近实时查询。

6）数据迁移使用XXL-Job：只保留当天数据，庞大的历史数据放到历史表。

7）SQL语句的选用：比如固定长度用char更快，比如用not exist(子查询仍然可以用索引查找是否存在)替代not in（索引失效，因为需要遍历判断）性能更好。

##### sql的生命周期
应用服务器与数据库建立连接
数据库进程拿到请求的sql
然后进行解析并执行
数据读取到内存并进行处理
然后再与应用服务器连接，发送结果到客户端
关闭连接，释放资源

##### 索引
Mysql常用的索引有两种B-tree(实际是B+Tree)和Hash
B-tree是一个树，比如说开头是一个数字，比它小的就会在左边，比它大的在右边
B+Tree就是会把这个头节大于或等于它的放在右边，小于等于它的放在左边，叶子节点是存了所有数据的，可以看作一个链表，这样但我们差一个数据的时候就直接在叶子节点上查找

##### 聚簇索引、非聚簇索引、回表、索引覆盖、怎么解决回表

```tex
聚簇索引:就是主键索引，与储存数据在一块，找到索引就找到了数据。可以为主键也可以为唯一键
非聚簇索引：也叫辅助索引、二级索引，往往需要回表查询。
回表：根据非聚簇索引查到聚簇索引的信息，再根据聚簇索引查到所有的数据，进行了2次B+树，这种现象就叫做回表。
索引覆盖：就是非聚簇索引查询自己，不走聚簇索引，比如查询id和name,name是非聚簇索引，这样就不用走聚簇索引，直接就可以查出来，这就叫索引覆盖。
解决回表：就是查询你所需要的数据，不用select * ，使用索引覆盖。
```



#### 	锁

##### Synchronized的作用是什么 ，synchronized与Lock的区别

synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行，即保证线程的串行化。
synchronized 可以保证可见性、原子性、有序性三大特性。

  1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；

  2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；

3. synchronized机制在执行完相应的同步代码以后，自动地释放同步监视器

​     Lock需要手动的启动同步(lock()),同时结束同步也需要手动的实现（unlock()）

  4.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

##### synchronized可重入的原理           

重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁，且不再被阻塞。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。

##### Syncrhronized怎么保证可见性          

JMM中使用happens-before语义（即遵循happens-before关系，由JMM定义的规则）：

1）线程解锁前，必须把共享变量的最新值刷新到主内存中。

2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值。

（注意：加锁与解锁需要是同一把锁）
 通过以上两点，可以看到synchronized能够实现可见性

##### 死锁

指两个或者多个事务在同一个资源上互相占用，并请求锁定对方的资源，从而导致恶行循环的现象。
解决方法：
		1.如果不同程序会并发存取多个表，就约定一个相同的顺序来访问。
		2.在同一个事务中，做到一次锁定所需要的所有资源，以减少死锁发生的概率。
		3.对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；
		如果业务处理不好可以用分布式事务锁或者使用乐观锁。

##### 悲观锁

假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。一般多写的场景下用悲观锁就比较合适

##### 乐观锁

假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。适用于写比较少的情况下（多读场景）

##### 行级锁

行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。

##### 表级锁

 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。

#### 多线程

##### 创建线程的方式
1.继承Thread类
2.实现Runnable接口
3.实现Callable接口
4.使用线程池
5.本地线程

##### Rubbable和Callable的区别
 Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值。run 方法只能抛出运行时异常，且无法捕获处理，call 方法允许抛出异常，可以获取异常信息。

##### 线程的 run()和 start()有什么区别
start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。
start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码；此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。
run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。

##### 线程有哪几种状态
1.新建状态（new）--创建线程
2.就绪状态（runnable）--start方法
3.阻塞状态（blocked）--无法获取锁对象（线程没抢到）
4.等待状态（waiting）--wait方法
5.计时状态（timed waiting）--sleep方法
6.死亡状态（terminated）--代码运行完毕

##### 线程的创建过程
1.创建Callable的实现类，实现call()方法，然后创建该实现类的实列
2.使用FutureTask类来包装Callable对象，FutureTask封装了Callable对象的call()方法的返回值
3.使用FutureTask对象作为Thread对象的target创建并启动线程
4.调用FutureTask对象的get()方法获得子线程执行结束后的返回值

##### sleep和wait的区别
sleep方法不会释放资源，期间其他线程不能进来，一般都是设置一个睡眠时间，时间到了自动苏醒，而wait可以释放资源，其他线程可以进来。另外wait不会自动苏醒，需要调用一个notify()方法或者notifyAll()方法来唤醒。
##### notify()和notifyAll()有什么区别？
notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程       
notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。

##### 有哪几种常见的线程池
1.单例线程池（newSingleThreadExecutor）
2.固定大小线程池（newFixedThreadPool）
3.可缓存线程池（newCachedThreadPool）
4.大小无限线程池（newScheduledThreadPool）

##### 线程池七大核心参数
参数一：核心线程数（不能小于0）
参数二：最大线程数（>=核心线程数）
参数三：临时线程最大存活时间（不能小于0）
参数四：时间单位（参数三的单位）	
参数五：等待列队（不能为null）
参数六：创建线程工厂（不能为null，一般用默认线程工厂）
参数七：任务的拒绝策略（不能为null）
##### 拒绝策略有哪些
丢弃任务并抛出异常（默认）
丢弃任务，不抛异常（不推荐）
丢弃等待最久的线程
调用执行自己的线程（main）运行run方法

#### JVM

java虚拟机主要分为以下几个区:

```tex
1.方法区
主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用
2.虚拟机栈（栈内存）
方法执行的地方，执行的时候创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息，局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用
3.本地方法栈
本地方法栈：
本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务
4.堆：
通过new关键字, 创建对象都会使用堆内存
特点：
它是线程共享的, 堆中对象都需要考虑线程安全的问题
有垃圾回收机制(不在被引用的对象会被回收）
5.程序计数器
内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成
```

##### java类加载过程

```tex
1)加载
加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：
a.通过一个类的全限定名获取该类的二进制流。
b.将该二进制流中的静态存储结构转化为方法去运行时数据结构。 
c.在内存中生成该类的Class对象，作为该类的数据访问入口。
2)验证
验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证: 
	a.文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. 
	b.元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。
	c.字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。
	d.符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。
	e.准备
	准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
3)解析
该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。
4)初始化
初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。
```

##### 什么是类加载器，类加载器有哪些?

```tex
实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。
主要有一下四种类加载器: 
1)启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
2)扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3)系统类加载器（system class loader）也叫应用类加载器：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
4)用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。
```

##### GC垃圾回收机制
1.标记-清除算法：
就是标记已经没有用处的对象，然后进行一个清除回收。缺点就是效率不高，无法清除垃圾碎片
2.复制算法：
就是将容量分为两个大小相等的内存区域，当其中一个内存区域用完的时候，就把一些还是存活的对象复制到另一个里，之后就对用完的那个内存区域一次清理掉。缺点就是对内存使用的效率不高，只是用了原来的一半。
3.标记-整理算法：
就是把那些已经没有用的对象进行一个标记，将还有用的对象都整理到一边，然后删除那些在边界外的没用的对象。
4.分代算法：
就是根据对象的一个存活周期的不同，将内存划分为不同的区域，基本分为老年代和新生代，对新生代进行一个复制算法，对老年代进行一个整理算法。

**2.0 高并发**

三要素


原子性：一个或多个操作要么全部执行成功，要么全部执行失败。

可见性：一个线程对共享变量的修改，另一个线程能够立刻看到（synchronized,volatile）。

有序性：程序执行的顺序按照代码的先后顺序执行。（有序性不代表禁止指令重排）。

**java内存模型？**

首先，JAVA内存模型是指JMM，而不是指内存结构，内存结构是在物理上的区域划分，而JMM则是抽象概念上的划分。

JMM（内存模型）主要包括两块：**主内存**+**工作内存**。

主内存：多个线程间通信的共享内存称之为主内存，即，数据是多个线程工共享的，在物理内存结构上通常对应“堆”中的线程共享数据。

工作内存：多个线程各自对应自己的本地内存，即，数据只属于该线程自己的，在物理内存结构上通常对应“本地方法栈”中的线程私有数据。

Java内存模型规定了所有的变量都存储在主内存(Main Memory)中，每条线程还有自己的工作内存(Working Memory)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存来实现。

**volatile关键词**

保证可见性，和禁止指令重排（ 

volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。）

**MESI缓存一致**

M（修改, Modified）: 本地处理器已经修改缓存行, 即是脏行, 它的内容与内存中的内容不一样. 并且此cache只有本地一个拷贝（专有）。

E（专有, Exclusive）: 缓存行内容和内存中的一样, 而且其它处理器都没有这行数据。

S（共享, Shared）: 缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝。

I（无效, Invalid）: 缓存行失效, 不能使用。

**指令重排**

对于volatile修改变量的读写操作，都会加入内存屏障。

每个volatile写操作前面，加StoreStore屏障，禁止上面的普通写和他重排；每个volatile写操作后面，加StoreLoad屏障，禁止跟下面的volatile读/写重排。

每个volatile读操作后面，加LoadLoad屏障，禁止下面的普通读和voaltile读重排；每个volatile读操作后面，加LoadStore屏障，禁止下面的普通写和volatile读重排

#### Spring
##### 常用的注解
	@Component--用来取代xml中的<bean id="">
	@Controller--用于Controller层
	@Service--用于Service层
	@Bean--用来创建Bean对象
	@Autowired--本地注入
	@Aspect--定义在方法上，设置当前类为切面类

##### IOC、AOP
ioc控制反转，他是一个思想，用于程序间的耦合问题。原本我们在创建对象时，控制权是在我们自己手中，需要我们自己来new对象，在这里我们就把这个控制权交给Spring来管理，我们可以通过配置文件来配置即可。简单来说就是一个工厂，只不过比普通的要强大很多。	

IOC原理:工厂模式+反射机制

aop是面向切面编程，在面向切面编程中，可以将一些对象中相似的方面抽成一个切面，进行统一管理，进行一些公共的操作。比如日志、事务处理等

##### Spring切面可以应用5种类型的通知
前置通知（Before）：在目标方法被调用之前调用通知功能；

后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；

返回通知（After-returning ）：在目标方法成功执行之后调用通知；

异常通知（After-throwing）：在目标方法抛出异常后调用通知；

环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。

##### Bean的生命周期
1.定义Bean--在配置文件里用<bean></bean>来定义
2.初始化Bean--
      	(1)在配置文件中通过指定init-method属性完成
      	(2)通过实现Initializing接口完成
3.调用Bean--
4.销毁Bean--
      	(1)配置文件中的destroy-method
      	(2)实现DisposeableBean接口

##### Spring 框架中都用到了哪些设计模式
工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；

单例模式：Bean默认为单例模式。

代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；

模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。

观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。

##### Bean对象的创建方式有哪几种
1、通过IoC直接创建bean对象

2、通过IoC创建bean工厂，再通过bean工厂的方法创建bean对象

3、通过IoC创建bean工厂，再通过bean工厂的静态方法创建bean对象

##### 循环依赖怎么解决
二级缓存：	
   	当创建A时，调用A的构造，然后准备对A进行依赖注入，此时发现A依赖与B，这时就会创建B，调用B的构造，此时发现B有依赖与A，这时就会创建一个半成品池，把A放在半成品池里，
   	 然后对B进行填充属性的时候，会先判断单列池中是否有A，没有就在半成品池中找A，得到A之后，初始化成功，将B放在单列池，再对A填充属性时，就会得到这个B，这样循环依赖就解决了。
   	  但是这样解决不了AOP代理的一个问题，此时就会用到三级缓存。
	

#### Spring Cloud
##### Spring Cloud和Dubbo的区别
Dubbo是实现了服务的治理，而Spring Cloud是分别覆盖了微服务架构下的众多部件。Dubbo是基于TCP协议传输的，配合以Hession序列化完成RPC通信。而SpringCloud是基于Http协议+rest接口调用远程过程的通信，REST相比RPC更为灵活，在微服务环境下更为合适服务之间的调用。

##### Spring Cloud有哪些组件
服务注册与发现---Nacos
客户端的负载均衡---Ribbon
断路器---Hystrix
网管---Spring Cloud Gateway
分布式配置---Spring Cloud Config
Hystrix：
	就是对服务的一个保护作用，有隔离，降级，熔断，限流
Gateway:
	就是相当于一个过滤器，用户请求到后台，是先到Gateway，然后再进行一个请求的转发，转发到指定的服务。

Ribbon：
   主要有两大功能:
        1.简化远程调用---通过服务的名称找到服务，自动进行URL的拼接；
        2.负载均衡---创建代理对象
     负载均衡策略:
        1.随机
        2.轮询
        3.最小并发（就是访问访问次数最小的）
        4.过滤（就是过滤掉那些坏掉的以及并发太高的）
        5.响应时间
       	6.轮询重试（就是再来一次轮询）
        7.性能的可用性（综合判断性能）
Feign：
	Feign是对Ribbon的封装，可以做负载均衡，但本质作用是用来实现服务之间的远程调用，这样既不用去写URL。
	

#### Spring Boot
首先Spring Boot是对Spring快速使用的方式，主要是为了简化xml配置文件和依赖管理我们可以在启动类上加上@SpringBootApplition注解，这也是Spring Boot的核心注解，表明这是一个Spring Boot应用。

##### Spring Boot有哪些核心注解：
@SpringBootApplition表明这是一个Spring Boot应用
@SpringBootConfiguration 组合了@Configuration注解，实现配置文件功能
@EnableAutoConfiguration 自动装配功能
@ComponentScan Spring组件扫描

##### SpringBoot的工作原理/自动配置/SPI机制是怎么样子的

SpringBoot使用的@SpringApplication注解，然后使用@EnableAutoConfiguration以及@ComponentScan自动装配，注解@EnableAutoConfiguration使用了@Import加载，使用@Import导入的类会被Spring加载到IOC容器中，最后使用了SpringFactoriesLoader反射出maven中META-INF下spring.factories，将反射的bean对象加载到Spring容器中（也就是SpringBoot的SPI机制）。

##### bootstrap.properties和application.properties有何区别
bootstrap是由父ApplicationContext加载的，适用于SpringCloud中，因为需要加载一些远程配置文件，比如Spring Cloud Config或者Nacos
application由ApplicationContext加载，用于Spring Boot项目的自动化配置。

#### Spring MVC
##### Spring MVC执行流程
1.用户发送请求到前端控制器
2.前端控制器获得请求后，调用处理器映射器，获得请求处理器
3.处理器映射器根据请求URL找到具体的处理器，生成处理器对象以及处理器拦截器一并返回给前端控制器
4.前端处理器调用HandlAdapter，经过适配调用具体的处理器Handler
5.处理器Handler执行完成后返回ModelAndView，通过调用视图解析器ViewResolver，解析视图返回具体的View
6.前端处理器对返回的视图View进行渲染，填充到对应的模型中最后响应给用户

**SPI**

SPI全称是service provider interface（服务提供接口），它是Java内置的服务发现机制，其核心思想是为了**解耦**。

通过SPI机制，可以将原本写在web.xml中的配置以注解的方式配置，而SPI其实就是通过注解来实现对相关配置类或实现类进行自动调用。

它是通过在 classPath （resources目录）路径下的 META-INF/services 文件夹查找服务，借助ServiceLoadder类实现自动加载文件里所定义的接口实现类

# MQ
## 优势
1、应用解耦（核心）：降低系统的耦合性，提升可维护性。

场景：服务调用之间都可以考虑MQ。

2、异步提速：提升用户体验和系统吞吐量。

场景：发送订单消息、发送短信消息等。

3、削峰填谷：减少高峰时期对服务器的压力。

场景：秒杀活动、限时定购等。

## 消息丢失(可靠性)
1、在生产者丢失——confirm确认模式
1）使用RabbitMQ事务机制，但它是同步的，且很耗性能。
2）开启confirm确认模式，确认消息是否从“生产者”发送到“交换机”，成功回传ack消息，失败可以重试或抛异常。且confirm模式是异步回调接口通知MQ是否接收到消息。一般都采用这种方式。

2、在MQ中丢失——持久化
开启RabbitMQ持久化，防止RabbitMQ自己弄丢数据。除非极小概率还没来得及持久化，MQ就先挂了，即使这样，也只会丢失极少的数据量。

所以，持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。

但持久化的过程也是很耗性能的。

3、在消费者丢失——ack机制
用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。

## 消息不重复消费
方法一：采用乐观锁机制保证消息幂等性。在数据库中会增加一个版本字段，执行时也会匹配版本，如果版本不一致，SQL语句的匹配就不成立，就不会执行。

方法二：你拿到这个消息做数据库的insert操作，那就容易了，给这个消息做一个唯一的主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。

方法三：你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。

