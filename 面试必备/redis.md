[TOC]



##### 持久化方式

1）RDB： RDB就是将内存中的数据以二进制快照的方式记录到硬盘中，当Redis出现故障重启后，会从硬盘中读取快照文件，来进行一个数据回复。
执行bgsave命令
	执行bgsave命令时,Redis进程会判断当前是否存在执行RDB或者AOF
	然后会执行fork操作创建一个子进程，此时别的请求是进不来的，以免导致数据的不一致
	然后子进程开始对内存中的数据进行一个读操作，写到新的RDB文件中，会覆盖旧的RDB文件
	当子进程对数据读完后，主进程就会对副本数据和子进程读取的数据进行一个写的操作

2）AOF：Redis处理的每一个写命令都会记录在AOF文件中，也可以看作是一个命令日志文件。
因为记录的时命令，所以AOF对RDB文件大。
如果同一个key多次操作的话，也一直会记录这些操作但只有最后的写操作才有意义，可以通过执行bgrewriteaof命令让AOF文件执行重写功能，用最少的命令达到一个相同的效果。

在实际应用中我们会对两个结合来进行使用。


##### 热点数据持久化

采用淘汰策略：
	使用次数最少的
    使用最近一次时间距现在最久的
    过期时间最近的
	

##### 数据持久化失效

采用集群主从的方式，如果主服务器失效，就用从服务器的。

##### 怎么保持数据库与Redis数据同步

当数据库数据发生改变时，再查询返回更新后的数据，然后再更新到Redis中，如果服务多的情况下，使用MQ来获取Mysql中日志的修改顺序，然后一次发送到Redis，因为Mysql的记录时先后更改后的执行顺序，MQ可以根据这个顺序保证先后的更新顺序，让Redis的顺序不会出现问题。

##### Redis存在的问题

缓存与数据库的一致性
缓存雪崩问题
缓存击穿问题
缓存的并发竞争问题

##### 什么是缓存雪崩，缓存击穿，缓存穿透

缓存雪崩：
	就是指某一时段，缓存中的大量数据过期失效，从而导致大量的请求过来，压力都集中到了数据库
		解决办法：
			1.设置一个缓存过期时间，不要一样的要错开，设置热门数据永不过期
			2.进行多级缓存，每一个缓存都是一个集群，相同的数据在多个服务器之间进行缓存
			3.优化数据库
			
缓存穿透：
	就是反复查询一个不存在的数据，导致数据库压力过大，一般是恶意攻击
		解决办法：
			将这个查询不到的数据设为null，并放入缓存中，在设置一个短的有效时间。
			用户身份验证
			布隆过滤器，对不存在的key直接过滤掉
			
缓存击穿：
	值一个比较热点的数据在缓存中失效了，导致大量请求瞬间到数据库中。
			解决办法:
				就是设置一个比较长的有效时间。
				

##### Redis删除策略

定时删除:
	创建一个定时器，当key设置的过期时间到达时，定时器任务就会立即对键进行删除操作。
	
惰性删除：
	在定时删除中可能存在没有被删除的key，这时就会先判断这个key是否过期，如果过期就删除，如果没过期就进行后续的操作。
	
定期删除：
	Redis默认美一秒钟进行10此过期扫描，在过期字典中随机出20个key，删除这20个key中过期的key，如果过期的key的比率超过1/4，就重复步骤1，同时为了保证线程不被卡死的现象，增加了对扫描时间的上限，默认不超过25ms，如果同一时间大量的key过期，为了避免Redis持续对过期字典的扫描，在设置过期时间时，可以给过期时间设置一个时间范围，
	避免同一时间过期。

##### redis为什么速度快

1.因为大部分请求基于内存操作的
2.采用单线程，避免了不必要的上下文切换和竞争条件
3.非阻塞IO多路复用

##### Redis为什么是单线程的

Redis底层主要是三大部分：IO多路复用+队列+文件事件分派器，文件时间分派器就是用来分派文件执行任务的，并且单但线程的，所以说Redis是单线程的。还有就是Redis是C编写的，基于内存来运行的，所以他的IO速度快，相对来说主要占用的是CPU的资源，如果采用多线程的话反而会导致占用CPU资源过大，降低效率，对于不是处理海量数据的话，使用Redis效率还是比较高的。